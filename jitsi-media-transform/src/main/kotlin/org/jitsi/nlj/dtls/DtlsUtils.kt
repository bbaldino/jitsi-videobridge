/*
 * Copyright @ 2018 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jitsi.nlj.dtls

import org.bouncycastle.asn1.ASN1Encoding
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x500.X500NameBuilder
import org.bouncycastle.asn1.x500.style.BCStyle
import org.bouncycastle.asn1.x509.Certificate
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.crypto.AsymmetricCipherKeyPair
import org.bouncycastle.crypto.generators.RSAKeyPairGenerator
import org.bouncycastle.crypto.params.RSAKeyGenerationParameters
import org.bouncycastle.crypto.tls.SRTPProtectionProfile
import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory
import org.bouncycastle.operator.DefaultDigestAlgorithmIdentifierFinder
import org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder
import org.bouncycastle.operator.bc.BcDefaultDigestProvider
import org.bouncycastle.operator.bc.BcRSAContentSignerBuilder
import java.math.BigInteger
import java.security.SecureRandom
import java.time.Duration
import java.util.*

class DtlsUtils {
    companion object {
        /**
         * Finds the first value that appears in both [ours] and [theirs]
         */
        //TODO: typealias for SRTPProtectionProfileArray?
        fun chooseSrtpProtectionProfile(ours: IntArray, theirs: IntArray): Int {
            return try {
                theirs.first(ours::contains)
            } catch (e: NoSuchElementException) {
                //TODO: define a value mapped to 0 which is something like "INVALID_SRTP_PROTECTION_PROFILE"
                0
            }
        }

        /**
         * Computes the fingerprint of a [certificate] using [hashFunction] and return it
         * as a [String]
         */
        fun computeFingerprint(certificate: org.bouncycastle.asn1.x509.Certificate, hashFunction: String): String {
            val digAlgId = DefaultDigestAlgorithmIdentifierFinder().find(hashFunction.toUpperCase())
            val digest = BcDefaultDigestProvider.INSTANCE.get(digAlgId)
            val input: ByteArray = certificate.getEncoded(ASN1Encoding.DER)
            val output: ByteArray = ByteArray(digest.digestSize)

            digest.update(input, 0, input.size);
            digest.doFinal(output, 0);

            return output.toFingerprint()
        }

        private val HEX_CHARS = "0123456789ABCDEF".toCharArray()
        /**
         * Helper function to convert a [ByteArray] to a colon-delimited hex string
         */
        private fun ByteArray.toFingerprint(): String {
            val buf = StringBuffer()
            for (i in 0 until size) {
                val octet = get(i).toInt()
                val firstIndex = (octet and 0xF0).ushr(4)
                val secondIndex = octet and 0x0F
                buf.append(HEX_CHARS[firstIndex])
                buf.append(HEX_CHARS[secondIndex])
                if (i < size - 1) {
                    buf.append(":")
                }
            }
            return buf.toString()
        }

        /**
         * Determine and return the hash function (as a [String]) used by this certificate
         */
        private fun org.bouncycastle.asn1.x509.Certificate.getHash(): String {
            val digAlgId = DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm)

            return BcDefaultDigestProvider.INSTANCE
                .get(digAlgId)
                .algorithmName
                .toLowerCase()
        }

        private val RSA_KEY_PUBLIC_EXPONENT = BigInteger("10001", 16)
        private const val RSA_KEY_SIZE = 1024
        private const val RSA_KEY_SIZE_CERTAINTY = 80
        /**
         * Return a pair of RSA private and public keys.
         */
        fun generateRsaKeyPair(): AsymmetricCipherKeyPair {
            val generator = RSAKeyPairGenerator();
            generator.init(
                RSAKeyGenerationParameters(
                        RSA_KEY_PUBLIC_EXPONENT,
                SecureRandom(),
                RSA_KEY_SIZE,
                RSA_KEY_SIZE_CERTAINTY)
            );
            return generator.generateKeyPair();
        }

        /**
         * Generates a new subject for a self-signed certificate to be generated by
         * <tt>DtlsControlImpl</tt>.
         *
         * @return an <tt>X500Name</tt> which is to be used as the subject of a
         * self-signed certificate to be generated by <tt>DtlsControlImpl</tt>
         */
        fun generateCN(appName: String, appVersion: String): X500Name {
            val builder = X500NameBuilder(BCStyle.INSTANCE)
            val rdn = "$appName $appVersion"
            builder.addRDN(BCStyle.CN, rdn)
            return builder.build()
        }

        /**
         * Generates a new self-signed certificate with a specific subject and a
         * specific pair of private and public keys.
         *
         * @param subject the subject (and issuer) of the new certificate to be
         * generated
         * @param keyPair the pair of private and public keys of the certificate to
         * be generated
         * @return a new self-signed certificate with the specified
         * <tt>subject</tt> and <tt>keyPair</tt>
         */
        fun generateX509Certificate(
                subject: X500Name,
                keyPair: AsymmetricCipherKeyPair,
                signatureAlgo: String = "SHA1withRSA"
        ): org.bouncycastle.asn1.x509.Certificate {
            val now = System.currentTimeMillis()
            val notBefore = Date(now - Duration.ofDays(1).toMillis())
            val notAfter = Date(now + Duration.ofDays(7).toMillis())
            val certBuilder = X509v3CertificateBuilder(
                subject,
                BigInteger.valueOf(now),
                notBefore,
                notAfter,
                subject,
                SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(keyPair.public)
            )
            val signatureAlgoIdentifier = DefaultSignatureAlgorithmIdentifierFinder().find(signatureAlgo)
            val digestAlgoIdentifier = DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgoIdentifier)
            val signer = BcRSAContentSignerBuilder(signatureAlgoIdentifier, digestAlgoIdentifier).build(keyPair.private)
            return certBuilder.build(signer).toASN1Structure()
        }

        /**
         * Generates a new certificate from a new key pair, determines the hash
         * function, and computes the fingerprint.
         *
         * @return CertificateInfo a new certificate generated from a new key pair,
         * its hash function, and fingerprint
         */
        fun generateCertificateInfo(): CertificateInfo {
            val keyPair = generateRsaKeyPair()

            val x509Certificate = generateX509Certificate(generateCN("TODO-APP-NAME", "TODO-APP-VERSION"), keyPair)
            val localFingerprintHashFunction = x509Certificate.getHash()
            val localFingerprint = computeFingerprint(x509Certificate, localFingerprintHashFunction)

            val now = System.currentTimeMillis()
            val tlsCert = org.bouncycastle.crypto.tls.Certificate(arrayOf(x509Certificate))
            return CertificateInfo(keyPair, tlsCert, localFingerprintHashFunction, localFingerprint, now)
        }
    }
}
